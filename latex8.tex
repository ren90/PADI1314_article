
%
%  $Description: Author guidelines and sample document in LaTeX 2.09$ 
%
%  $Author: ienne $
%  $Date: 1995/09/15 15:20:59 $
%  $Revision: 1.4 $
%

\documentclass[times, 10pt,twocolumn]{article} 
\usepackage{latex8}
\usepackage{times}

%\documentstyle[times,art10,twocolumn,latex8]{article}

%------------------------------------------------------------------------- 
% take the % away on next line to produce the final camera-ready version 
\pagestyle{empty}

%------------------------------------------------------------------------- 
\begin{document}

\title{PADI-DSTM}



\maketitle
\thispagestyle{empty}


%------------------------------------------------------------------------- 
\Section{Introduction}
Since the beginning of the computer revolution in the world, the distributed systems have played a major role in the technologies' innovation and development. This area comprises a great set of different technologies and aplications, like the network applications, telecommunication networks, parallel computation, etc. In the recent years we have been witnessing a new era in the technology, the Cloud era. Today the Cloud is the new "big thing" in computers and mobile devices, everyone can access everything  everywhere! As such, the transactional shared memory systems are increasingly important in the world of technology, because nowadays the computers and mobile devices are using the cloud storage, and the cloud potencial possibilities, like the Amazon Silk, that is a web browser that processes the requests from the clients in the Amazon servers, an the client's devices only have to renederer the result data. Due to this evolution of the distributed systems, the PADI-DSTM appeared,This library intends to implement a distributed system to manage the objects stored in a distributed shared memory, that are shared by transactional applcations that are being executed in diferent machines, this library intends to provide a easy way for the programers doesn't have to deal with the distributed systems and transactions problems, like deadlocks, inconsistent data or data that disappears, because a server fails, etc.,

%------------------------------------------------------------------------- 
\Section{Architecture Overview}
%DONE RENATO

This work focuses on implementing a transactional shared memory system, which stores variables of PADInt type. These variables will be shared between the multiple clients of the system and will be located in a set of transactional servers, that replicate information in case of failure occurrence. Clients, recurring to the PADI-DSTM library, create and access variables on the system recurring to a master server, which maintains information about, and manages the location of each one of them. Once accessed, clients can execute transactions, that encapsulate read and write operations on a subset of these variables, preserving the Atomicity, Consistency, Isolation and Durability (ACID) properties. One of the main concerns of this work is trying to implement the system in a decentralized way, minimizing the interaction with centralized entities. For doing so, it considers client as the transaction coordinator, in contrast with master, once it is assumed clients never crash. The interactions with the master server will be only for creating and accessing data objects. The system will consider a fault model which tolerates one silent failure. For doing so, it implements an active replication protocol with 3 replicas, and a quorum of 2 servers. The system will follow a two-phase commit protocol for executing the transactions, which, as mentioned before, will take as coordinator the transaction client, and as participants the servers which hold the involved data objects. Finally, the master server will be able to mediate the load between transactional servers, reallocating resources in order to preserve the equal distribution of network and storage loads, which favors the systems scalability. The next sections will expose the systems behavior with more detail.  


%------------------------------------------------------------------------- 
\SubSection{Data Structures}

Our PADI-DSTM library contains multiple data structures with different goals. In the Master server are stored the list of transactions unique identifiers that started and ended, in order to have a log of the transactions that have been completed, and if one transaction id only exists in the list of started transactions, this means that the transaction has been aborted. The servers continually send "I'm alive" messages to the Master which updates a list that contains the active servers, and when the client connects with the Master by calling the methods AccessPadInt or CreatePadInt, the Master only returns the active servers in the object that contains the PadInt. In "I'm alive" messages the servers also include the number of active connections at that time, in order to the master know whitch servers have a greater number of connections and when a client requests the servers to the master, the master only returns the ones with less number of connections.  

The PadInt object is the main one in our architecture, it is stored in the servers, and each PadInt exists in three servers, in order to tolerate faults. Each of the three objects is always updated to the last version, because when the changes to the object are committed, the new values are propagated to the other servers in which the object is stored. The PadInt object contains different sub-objects, its UID (to make each PadInt unique), its value, an array of the servers in which it is stored (we decided that each object know its own location, and the client decides which one to bind to, when he receives the object through the API). The PadInt object also contains a timestamp that it is used to control the accesses to the variable in the memory, in this case if the client timestamp is lower than the timestamp of the object it means that the client has an old version of the object and the transaction is aborted.

%------------------------------------------------------------------------- 
\SubSection{Responsibilities}

As seen before, our approach will be divided in three components, a master, a client and a transactional server, each one of them with distinct roles.
The master, has three main responsibilities. The first one is to store meta-data regarding transactional servers and data objects existing in PADI-DSTM. It stores among other information, object location and uid, or transactional servers location and network load. The second role of master server is to mediate the creation and access to shared variables. Clients connect to the master for getting remote objects that represent variables. In case of a creation, the master will choose the most unloaded transactional servers and  execute a create operation. Master is also the one who executes the load balancing algorithm, for coordinating and re-allocating resources. Basing on a timer, the master server will execute a load balancing algorithm, which distributes work equally amongst the servers.
The second one, the transactional servers will store and execute the changes made to the data objects, acting as participants of a distributed transaction protocol. They are responsible for managing the variable locks, committing or aborting transactions depending on the conditions they have for maintaining the ACID properties of each transaction. They also indicate the master their activity through a heartbeat message, which carries the number of active connections, informing the master of their current network load.  
Finally, clients will execute the programs that use the PADI-DSTM library, invoking the creation/access to the objects on the master and manipulating them on the transactional servers. Clients will also, through the PADI-DSTM library, act as coordinators for the transactions they trigger. Clients connect to the servers that are currently storing the variables they want to modify and trigger a two-phase commit protocol.

%------------------------------------------------------------------------ 
\SubSection{Concurrency Control}
With a distributed system, there's a problem that is inherent to this type of architecture: concurrent access to shared objects. In this particular case, we have to take into consideration that objects can be accessed by multiple clients and, when committing the changes, the objects may be accessed by several servers as well.
To manage this type of concurrency, we will be using timestamp-based concurrency control. This type of approach assigns a timestamp (which can be a time value or a sequence number) to the transactions that want to have access over a certain object. This object also keeps a timestamp of its own and also keeps track of the latest transaction that read/wrote the object's value. With this kind of approach, the transactions are forced, in a sense, to access the object in a specific order, so that there are no actual parallel accesses.
One aspect that is important to mention is that there is still a lock on the object that is being accessed, though this is not a "fully grown" lock as it would be in database lock-based concurrency control. The lock is to prevent concurrent access to an object, though the time the lock is locked is significantly smaller and there is no chance of deadlocking since the lock is immediately released when it's no longer needed, as opposed to lock-based concurrency control in which the locks are released at the end of the transaction.

%------------------------------------------------------------------------- 
\SubSection{Transactional Algorithms}

%TODO: RENATO



%------------------------------------------------------------------------- 
\SubSection{Distributed Protocols}

%TODO: RENATO

%------------------------------------------------------------------------- 
\SubSection{Deadlock Detection and Abort Recovery}
Bearing in mind that we're using timestamps to prevent concurrent access to shared objects, the greatest advantage when using this type of concurrency control is that there are no deadlock situations, since the access to shared objects aren't locked by another data type, like the locks used in database transactions or the OS's mutexes.
Even though this concurrency control method avoids deadlock through its implementation, there are some situations where the occurring transactions abort without a conflict of two (or more) of those transactions accessing the same shared object. This sort of thing happens when, for example, a transaction T1 has a timestamp value of 100 and another transaction T2 has a timestamp value of 200. If T2 tries to read an object (without altering its value) before T1, though there are no read-write/write-write/write-read conflicts, both T1 and T2 must abort because the access to the object wasn't sequential (since T1 has a lower timestamp value than T2).
To overcome what was stated above, we will take into account what actions the transactions want to execute. By doing so, if two transaction only read the value from an object without altering it, even if they perform these actions inconsistently with the assigned timestamps, there is no need to abort because the operations' outcome will never generate an inconsistency, as long as there aren't any modifications to the object's value.

\Section{Conclusions}

%------------------------------------------------------------------------- 

\bibliographystyle{latex8}
\bibliography{latex8}

\end{document}

