
%
%  $Description: Author guidelines and sample document in LaTeX 2.09$ 
%
%  $Author: ienne $
%  $Date: 1995/09/15 15:20:59 $
%  $Revision: 1.4 $
%

\documentclass[times, 10pt,twocolumn]{article} 
\usepackage{latex8}
\usepackage{times}

%\documentstyle[times,art10,twocolumn,latex8]{article}

%------------------------------------------------------------------------- 
% take the % away on next line to produce the final camera-ready version 
\pagestyle{empty}

%------------------------------------------------------------------------- 
\begin{document}

\title{PADI-DSTM}



\maketitle
\thispagestyle{empty}


%------------------------------------------------------------------------- 
\Section{Introduction}
Since the beginning of the computer revolution in the world, the distributed systems have played a major role in the technologies' innovation and development, and in the recent years we have been witnessing a new era in the technology, the Cloud era. Today the Cloud is the new "big thing" in computers and mobile devices, everyone can access everything  everywhere! As such, the transactional shared memory systems are increasingly important in the world of technology. Due to this evolution, the PADI-DSTM appeared, a library that is intended to manage the transactions between objects in a shared memory system, and avoid all the problems related to the distributed systems and transactions.

%------------------------------------------------------------------------- 
\Section{Solution Overview}
%DONE RENATO

This work focuses on implementing a transactional shared memory system, which stores variables of PADInt type. These will be located in a set of transactional servers, that replicate information in case of failure occurrence. Clients, recurring to the PADI-DSTM library, create and access variables through a master server, which maintains information about the location of each one of them. Once accessed, clients can execute read and write operations on variables. One of the main concerns of this work is trying to implement the system in a decentralized way, minimizing the interaction with centralized entities. For doing so, it considers client as the transaction coordinator, in contrast with master, once it is assumed clients never crash. The interactions with the master server will be only for creating and accessing data objects. The system will consider a fault model which tolerates one silent failure. For doing so, it implements an active replication protocol with 3 replicas. The system will follow a two-phase commit protocol for executing the transactions, which, as mentioned before, will take as coordinator the transaction client, and as participants the servers which hold the involved data objects. Finally, the master server will be able to mediate the load between transactional servers, favoring the systems scalability. The next sections will expose the systems behavior with more detail.  

%------------------------------------------------------------------------- 
\SubSection{Architecture}

%TODO: RENATO
%olhe la...isto nao sao as responsibilities????


For solving the problem stated in the scope of this work, our approach will be divided in three components.
The first component, a centralized master, that stores meta-data concerning every data object existing in PADI-DSTM, such as its location or uid, and it is responsible for mediating the creation and access to the PADInt objects. It is also the one who executes the load balancing algorithm, coordinating and re-allocating resources. The second one, the transactional servers will store and execute the changes made to the data objects, acting as participants of a distributed transaction protocol. Finally, clients will execute the programs that use the PADI-DSTM library, invoking the creation/access to the objects and manipulating them. Clients will also, through the PADI-DSTM library, act as coordinators for the transactions they trigger. 

%------------------------------------------------------------------------- 
\SubSection{Data Structures}

Our PADI-DSTM library contains multiple data structures with different goals. In the Master server are stored the list of transactions unique identifiers that started and ended, in order to have a log of the transactions that have been completed, and if one transaction id only exists in the list of started transactions, this means that the transaction has been aborted. The servers continually send "I'm alive" messages to the Master which updates a list that contains the active servers, and when the client connects with the Master by calling the methods AccessPadInt or CreatePadInt, the Master only returns the active servers in the object that contains the PadInt. In "I'm alive" messages the servers also include the number of active connections at that time, in order to the master know whitch servers have a greater number of connections and when a client requests the servers to the master, the master only returns the ones with less number of connections.  

The PadInt object is the main one in our architecture, it is stored in the servers, and each PadInt exists in three servers, in order to tolerate faults. Each of the three objects is always updated to the last version, because when the changes to the object are committed, the new values are propagated to the other servers in which the object is stored. The PadInt object contains different sub-objects, its UID (to make each PadInt unique), its value, an array of the servers in which it is stored (we decided that each object know its own location, and the client decides which one to bind to, when he receives the object through the API). The PadInt object also contains a timestamp that it is used to control the accesses to the variable in the memory, in this case if the client timestamp is lower than the timestamp of the object it means that the client has an old version of the object and the transaction is aborted.

%------------------------------------------------------------------------- 
\SubSection{Responsibilities}


%------------------------------------------------------------------------ 
\SubSection{Concurrency Control}
With a distributed system, there's a problem that is inherent to this type of architecture: concurrent access to shared objects. In this particular case, we have to take into consideration that objects can be accessed by multiple clients and, when committing the changes, the objects may be accessed by several servers as well.
To manage this type of concurrency, we will be using timestamp-based concurrency control. This type of approach assigns a timestamp (which can be a time value or a sequence number) to the transactions that want to have access over a certain object. This object also keeps a timestamp of its own and also keeps track of the latest transaction that read/wrote the object's value. With this kind of approach, the transactions are forced, in a sense, to access the object in a specific order, so that there are no actual parallel accesses.
One aspect that is important to mention is that there is still a lock on the object that is being accessed, though this is not a "fully grown" lock as it would be in database lock-based concurrency control. The lock is to prevent concurrent access to an object, though the time the lock is locked is significantly smaller and there is no chance of deadlocking since the lock is immediately released when it's no longer needed, as opposed to lock-based concurrency control in which the locks are released at the end of the transaction.

%------------------------------------------------------------------------- 
\SubSection{Transactional Algorithms}

%TODO: RENATO



%------------------------------------------------------------------------- 
\SubSection{Distributed Protocols}

%TODO: RENATO

%------------------------------------------------------------------------- 
\SubSection{Deadlock Detection and Abort Recovery}
Bearing in mind that we're using timestamps to prevent concurrent access to shared objects, the greatest advantage when using this type of concurrency control is that there are no deadlock situations, since the access to shared objects aren't locked by another data type, like the locks used in database transactions or the OS's mutexes.
Even though this concurrency control method avoids deadlock through its implementation, there are some situations where the occurring transactions abort without a conflict of two (or more) of those transactions accessing the same shared object. This sort of thing happens when, for example, a transaction T1 has a timestamp value of 100 and another transaction T2 has a timestamp value of 200. If T2 tries to read an object (without altering its value) before T1, though there are no read-write/write-write/write-read conflicts, both T1 and T2 must abort because the access to the object wasn't sequential (since T1 has a lower timestamp value than T2).
To overcome what was stated above, we will take into account what actions the transactions want to execute. By doing so, if two transaction only read the value from an object without altering it, even if they perform these actions inconsistently with the assigned timestamps, there is no need to abort because the operations' outcome will never generate an inconsistency, as long as there aren't any modifications to the object's value.

\Section{Conclusions}

%------------------------------------------------------------------------- 

\bibliographystyle{latex8}
\bibliography{latex8}

\end{document}

